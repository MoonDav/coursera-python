# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки. Известно, что все n селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.
#
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения определить ближайшее к нему бомбоубежище.
#
# Формат ввода
#
# В первой строке вводится число n - количество селений (1 <= n <= 100000). Вторая строка содержит n различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения. В третьей строке входных данных задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹. Селение и убежище могут располагаться в одной точке.
#
# Формат вывода
#
# Выведите n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
#
# Указание
#
# Создайте список кортежей из пар (позиция селения, его номер в исходном списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
#
# Перебирайте селения в порядке возрастания.
#
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо выбрать ближайшее. При переходе к следующему селению не обязательно искать ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции, найденной для предыдущего города.
#
# Для хранения ответа используйте список, где индекс будет номером селения, а по этому индексу будет запоминаться номер бомбоубежища.


n = int(input())
cities = map(int, input().split())
m = int(input())
shelters = list(map(int, input().split()))

for i in range(len(shelters)):
    shelters[i] = [i + 1, shelters[i]]

shelters.sort(key=lambda x: x[1])


def find_value(x):
    if x < shelters[0][1]:
        return shelters[0][0]
    if x > shelters[-1][1]:
        return shelters[-1][0]

    l = 0
    r = len(shelters) - 1

    while r - l > 1:
        m = (r + l) >> 1
        if shelters[m][1] < x:
            l = m
        else:
            r = m

    if x - shelters[l][1] < shelters[r][1] - x:
        return shelters[l][0]
    else:
        return shelters[r][0]


resList = [find_value(v) for v in cities]
print(*resList)
